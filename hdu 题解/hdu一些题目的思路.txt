HDU 一些题目的思路ACM HDU 2010-03-23 22:26:10 阅读107 评论0 字号：大中小 

HDU 1010 刚看这道题的时候，很容易被误导，以为用BFS求出最短路劲就行了。思路是完全错误的。因为题目问的是存不存在一条路径，使步数刚好是T。因此要枚举每一条路径出来，就需要用到DFS。要注意的是，题目的数据虽然只有7，但是必须剪枝，不然就会超时。剪枝包括：1、如果空白的点（包括S和D两个点）<=T，直接输出NO。2、奇偶性剪枝。（具体见下文），step % 2 == T % 2；3、与D点的最短路径小于T ，不用继续递归了。
         奇偶性剪枝
可以把map看成这样： 

0 1 0 1 0 1 

1 0 1 0 1 0 

0 1 0 1 0 1 

1 0 1 0 1 0 

0 1 0 1 0 1 

从为 0 的格子走一步，必然走向为 1 的格子 

从为 1 的格子走一步，必然走向为 0 的格子 

即： 

0 ->1或1->0 必然是奇数步 

0->0 走1->1 必然是偶数步 

结论： 

所以当遇到从 0 走向 0 但是要求时间是奇数的，或者， 从 1 走向 0 但是要求时间是偶数的 都可以直接判断不可达！ 

HDU 2141 想得太复杂了。虽然题目a[i]+b[j] + c[k] = x，但是不必用三层循环去枚举。先算num[k] = a[i] + b[j],

在num数组中找是否存在x - c[i] ;

HDU 1242 被题目忽悠了很久，其实就只有一个卫士和一个朋友，也就是只有一个r和x。而且用BFS去搜的过程中，如果没有遇到x是合理的。也就是可以找到S的情况下不用杀了X

HDU 1072 利用BFS搜索。区别的是不是用标记求出最短2到3之间最短的距离。因为必须满足一些条件。但是利用BFS，可以求出在满足条件的情况下的最短路径。原先在想如果不标记的话会不会重复的走同一条路径而导致超时，事实证明不会，也因为数据比较小。还有一个必要的剪枝，访问过的4其实不会再访问了，可以设为0.

HDU 1253 简单的BFS，只不过图是三维的。这道题可以剪枝，但是我没有剪。以后要记住在矩形或立方体下三种剪枝方法：求两点之间的距离，如果枚举到的点的step已经超过给出的时间T，可以剪掉；二、T - step<|x0 - x|+|y0 - y|，可以剪掉。还有就是上面介绍的奇偶剪枝

HDU 1312 简单的BFS，求出从@点出发，走遍全部的黑点需要的时间

HDU 1372 简单的BFS， 骑士是按“日”走的，走斜边，总共有8种走法

HDU 12381A，以为会改很多次。要注意一些细节：把最短的字符串拿出来截断后和其他的比较

HDU 1016 好开心，第一道自己抽象出来的DFS。看这道题的时候，很快的抽象出是用BFS写的，以为可以很快的写出来，看了第二个例子，才知道不是BFS，而是DFS。这就比较麻烦一点，因为没有自己完全写过DFS。这道题的关键是先把20以内每个数i对应相加为素数的数都枚举出来，对应存储在ve[i]中。用DFS去搜时，记得重新标记回点。还有一个就是当搜到的个数为n时，要判断1和最后一个是不是相加为素数。

HDU 1281使用二分图的最大匹配。难点在于如何转化为二分图的关系。这道题中，如果存在一个点（x , y），那么在x行或y列上都不可有其他点的存在。所以直接link[x][y] = 1；然后按一般的方法求出最大的匹配num。而最重要的点的思路：枚举每一个点，把它的关联去掉，即link[x][y] = -1，再算一次最大匹配，如果求出的最大匹配值不再是num，那么是重要的点。

HDU 1498和1281一样，如果在x行y列上存在一点，则link[x][y] = 1 ；枚举出现过的每一个数字，（用set容器装载这些数字，可使输出是升序），对每一个数字算他的最大匹配的值num，如果num>k，那么无法再k次中弄破该数字的气球，则这个数字要输出

HDU 1528 二分图的最大匹配。比较两个人的牌，如果第二人的第I张牌>第一个人的第j张牌，那么建立关系link[i][j] = 1。接下来就看二分的思想计算


