C
--------------------------------
#include<stdio.h>
#include<string.h>
typedef struct
{
        int a,b,c;
} data;
data x[90];
int d[90];
int n;
int dfs(int q)
{
    int i,best=0;
    if(d[q]) return d[q];
    for(i=0;i<n;i++)
    {
      if(x[i].a<x[q].a && x[i].b<x[q].b)
      {
        if(best<dfs(i)) best=dfs(i);
      }
    }
    d[q]=x[q].c+best;
    return d[q];
}
int main(void)
{
    int i,k=1,a,b,c;
    int best;
    while(scanf("%d",&n),n!=0)
    {
      n*=3;
      best=0;
      memset(d,0,sizeof(d));
      for(i=0;i<n;i++)
      {
        scanf("%d%d%d",&a,&b,&c);
        x[i].a=a; x[i].b=b; x[i].c=c;
        if(x[i].a>x[i].b) x[i].a^=x[i].b^=x[i].a^=x[i].b;
        i++; x[i].a=a; x[i].b=c; x[i].c=b;
        if(x[i].a>x[i].b) x[i].a^=x[i].b^=x[i].a^=x[i].b;
        i++; x[i].a=b; x[i].b=c; x[i].c=a;
        if(x[i].a>x[i].b) x[i].a^=x[i].b^=x[i].a^=x[i].b;
      }
      for(i=0;i<n;i++)
      {
        if(best<dfs(i)) best=dfs(i);
      }
      printf("Case %d: maximum height = %d\n",k++,best);
    }
    return 0;
}
----------------------------------------
C++
-------------------------

#include <iostream>
using namespace std;
#define MAXN 100

typedef struct Blocks
{
    int x, y, z;
}Blocks;



void change (int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

/* 排序函数 */
int cmp (const void *a,  const void*b)
{
    Blocks c = *(Blocks *) (a);
    Blocks d = *(Blocks *) (b);
    if (c.x < d.x) {
        return 1;
    } else if (c.x == d.x) {
        if (c.y < d.y) {
            return 1;
        } else if (c.y == d.y) {
            return c.z < d.z;
        }
    }
    return -1;
}



bool isSuit (int &i, int &j, Blocks block[])
{//如果a长小于a长 b宽小于b宽 OK 或者 a长小于b宽 且a宽小于b长 OK
    return  ((block[i].x < block[j].x && block[i].y < block[j].y) ||
        (block[i].y < block[j].x && block[i].x < block[j].y));
}


int calculator (Blocks block[], int &n)
{
    int i, j;

    for (i = 1; i < 3 * n; i++) {
        int cur_state = 0;// 当前状态
        for (j = 0; j < i; j++) {
            if (isSuit(i, j, block)) {//按题目要求是要求长和宽都必须比下一层的小就可 
                if (block[j].z > cur_state) {
                    cur_state = block[j].z;//找到前边如果有大的 就记下
                }
            }
        }
        block[i].z += cur_state; //记录下到当前的最大
    }
    int max = 0;//找到最大
    for (i = 0; i < 3 * n; i++) {
        //cout << block[i].z << endl;
        if (block[i].z > max)
            max = block[i].z;
    }

    return max;
}

void getOther (Blocks *block, int &x, int &y, int &z)
{
    (*block).x = x;
    (*block).y = y;
    (*block).z = z;    
    /* 如果长小于宽 就交换*/            
    if ((*block).x < (*block).y) {
        change (&(*block).x, &(*block).y);
    }
}


int main (void)
{
    Blocks block[MAXN];
    int n, x, y, z;
    static int count = 0;

    while (cin >> n && n) {
        /*输入 且两个两个交换*/
        for (int i = 0; i < 3 * n; i += 3) {
            cin >> x >> y >> z;
            getOther (&block[i], x, y, z);
            getOther (&block[i + 1], z, y, x);
            getOther (&block[i + 2], x, z, y);
        }
        
        /* 按照从大到小排序 先是长 再宽 再高 */
        qsort (block, 3 * n, sizeof(Blocks), cmp); 

        cout << "Case " << ++count 
            << ": maximum height = " << calculator (block, n) << endl;
    }

    //system ("pause");
    return 0;
}

        