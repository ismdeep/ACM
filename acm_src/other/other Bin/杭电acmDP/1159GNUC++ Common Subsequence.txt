#include <cstdio>
#include <cstring>
#include <ctime>

typedef unsigned long long BitType;

const int M                        = 62;
const int Limit_Size            = 50000 + 10;
const int Limit_CharSet            = 256;
const int Limit_BitArray_Leng    = Limit_Size / M + 10;
const BitType Top                = ((BitType) 1 << (M));
const BitType TopLess            = Top - 1;
const BitType UnderTop            = ((BitType) 1 << (M - 1));

typedef BitType BitArray[Limit_BitArray_Leng];

int n , m , Ln;
char A[Limit_Size];
char B[Limit_Size];
BitArray Comp[Limit_CharSet];

void Process()
{
    bool calced[Limit_CharSet];
    memset(calced , 0 , sizeof(calced));

    int i , u , p;
    for(i = 0; i < m; i ++)
    {
        u = B[i];
        if(calced[u]) continue;
        calced[u] = 1;

        memset(Comp[u] , 0 , sizeof(Comp[u]));
        for(p = 0; p < n; p ++)
            if(u == A[p])
                Comp[u][p / M] ^= ((BitType)1 << (p % M)); 
    }
}

BitArray Row[2];
BitArray X;

void Solve()
{
    memset(Row , 0 , sizeof(Row));
    
    int Prev , Curt;
    int i , u , p , c , cc;
    Ln = (n / M) + 1;

    Prev = 0;
    for(i = 0; i < m; i ++)
    {
        Curt = 1 - Prev; u = B[i];
        
        // X = Row[Prev] or Comp[u]
        // Row[Curt] = X and [ (X - ((Row[Prev] << 1) + 1)) xor X ]
        for(p = 0; p < Ln; p ++)
            X[p] = Row[Prev][p] | Comp[u][p];
        c = 0;
        for(p = 0; p < Ln; p ++)
        {
            cc = (Row[Prev][p] & UnderTop) > 0;
            Row[Prev][p] = ((Row[Prev][p] & (UnderTop - 1)) << 1) + c;
            c = cc;
        }
        for(p = 0; p < Ln; p ++)
        {
            if(Row[Prev][p] != TopLess)
            {
                Row[Prev][p] ++; break;
            }
            Row[Prev][p] = 0;
        }
        c = 0;
        for(p = 0; p < Ln; p ++)
        {
            if(X[p] >= Row[Prev][p] + c)
                Row[Prev][p] = X[p] - (Row[Prev][p] + c) , c = 0;
            else
                Row[Prev][p] = Top + X[p] - (Row[Prev][p] + c) , c = 1;
        }
        for(p = 0; p < Ln; p ++)
            Row[Curt][p] = X[p] & (Row[Prev][p] ^ X[p]);
        
        Prev = Curt;
    }

    int Ret = 0;
    for(i = 0; i < n; i ++)
        if(Row[Prev][i / M] & ((BitType)1 << (i % M))) Ret ++;
    printf("%d\n" , Ret);
}

int main()
{
    while ( scanf("%s%s", A, B) != EOF )
    {
        n = strlen(A);
        m = strlen(B);
        Process();
        Solve();
    }
    return 0;
}